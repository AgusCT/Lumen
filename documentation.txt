To use the scheduler, do
	local sched=require('sched')


sched.run(f, [params...])
	Creates a task. The task will emit a ('die', true, params...) signal upon normal
		finalization, were params are the returns of f. If there is a error, the 
		task will emit a ('die', false, err), were err is the error message.
	Parameters
		f: function for the task
		params: parameters pased to f upon first run.
	Returns
		task in the scheduler.


sched.signal(event, [args...])
	Emits a signal from a task.
	Parameters
		event: event of the signal. Can be of any type.
		args: further parameters to be sent with the signal.


sched.wait(waitd)
	Blocks a task waiting for one or more events, or a timeout.
	Parameters
		waitd: a wait descriptor. It is a table containig the fields:
			emitter: optional, task originating the signal we wait for. If
				nil, will only return on timeout. If '*', means anyone.
			timeout: optional, time to wait. nil or negative waits for ever.
			events: optional, array with the events to wait.
			A wait descriptor can be reused (for example, when waiting 
			inside a loop) and shared amongst different tasks. If a wait
			descriptor changes while there is a task waiting, the behaviour 
			is uspecified.
	Returns
		the signal received as (event, args...) (see sched.signal()); on timeout 
		expiration, returns (nil, 'timeout').


sched.waitd(emitter, timeout, [events...])
	Helper function that instantiates a wait descriptor (see sched.wait()).
	Parameters
		emitter: task originating the signal we wait for. If nil, will only
			return on timeout. If '*', means anyone.
		timeout: time to wait. nil or negative waits for ever.
		events: events to wait.
	Returns
		A wait descriptor object.


sched.sleep(t)
	Sleeps the task for t time units. Same as sched.wait({timeout=t})
	Parameters
		t: time to sleep.


sched.yield()
	Yields the execution of a task, as in cooperative multitasking.
	Returns
		availabletime: time available until other tasks are capable of running. If
			there are other active (yielded, non-waiting) tasks, this will be 0.
		availabletimeuntiltimeout: time available until the nearest timeout of a
			waiting task.


M.sigrun(f, waitd)
	Creates a task that will run on a given signal. For more details see sched.wait()
	and sched.run()
	Parameters
		f: function for the task. The function will receive the signal.
		waitd: wait descriptor, as used in sched.wait()
	Returns
		the created task.


M.sigrunonce(f, waitd)
	Creates a task that will run on a given signal once, and terminate. For more 
	details see sched.wait() and sched.run()
	Parameters
		f: function for the task. The function will receives the signal.
		waitd: wait descriptor, as used in sched.wait()
	Returns
		the created task.


sched.kill([task])
	Finishes a task. When killed, a task will emit a signal ('die', false, 'killed')
	Parameters
		task: task to terminate. If nil, terminates the current task.


sched.catalog.register(name)
	Register a name for the task. 
	Parameters
		name: can be of any type.
	Returns
		true is succesfull; (nil, 'used') if the name is already used by another 
		task.


sched.catalog.waitfor(name, [timeout])
	Look for the task with the given name. Can wait up to timeout until it appears. 
	Parameters
		name: can be of any type.
		timeout: time to wait. nil or negative waits for ever.
	Returns
		the task if succesfull; on timeout expiration returns (nil, 'timeout').


sched.catalog.tasks()
	Iterator for registered tasks
	Returns:
		Example use:
		for name, task in sched.catalog.tasks() do print(name, task) end
	

sched.get_time
	Function used by the scheduler to get current time; replace with whatever 
	your app uses. LuaSocket's gettime works just fine. Defaults to os.time.


sched.idle
	Function called by the scheduler when there is nothing else to do (e.g., all tasks
	are waiting for a signal). This function should idle up to t time units. Replace with
	whatever your app uses. LuaSocket's sleep works just fine. It is allowed to idle for
	less than t; the empty function will result in a busy wait. Defaults to execution of
	Linux's "sleep" command.


sched.go()
	Starts the scheduler. Will run until there is no more activity, i.e. there's no
	active task, and none of the waiting tasks has a timeout set.


sched.step() 
	Runs a single step of the scheduler. 
	Returns 
		the idle time available until more activity is expected; this means it will
		be 0 if there are active tasks. 

--End
